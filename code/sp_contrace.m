function N = sp_contrace(C,P,grad_img,g)
%在beClose中用到来进行Single-point Contour Trace
grad_img = double(grad_img);
cell_cp={[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1]};   %8邻域的相对位置
% cell_n={[-1,1],[1,1],[0,1],[-1,0],[1,0];
%         [-1,0],[0,1],[-1,1],[-1,-1],[1,1];
%         [-1,-1],[-1,1],[-1,0],[0,-1],[0,1];
%         [0,-1],[-1,0],[-1,-1],[-1,1],[1,-1];
%         [1,-1],[-1,-1],[0,-1],[-1,0],[1,0];
%         [1,0],[0,-1],[1,-1],[1,1],[-1,-1];
%         [1,1],[1,-1],[1,0],[0,-1],[0,1];
%         [0,1],[1,0],[1,1],[1,-1],[-1,1]};

cell_n={[-1,1],[1,1],[0,1];
        [-1,0],[0,1],[-1,1];
        [-1,-1],[-1,1],[-1,0];
        [0,-1],[-1,0],[-1,-1];
        [1,-1],[-1,-1],[0,-1];
        [1,0],[0,-1],[1,-1];
        [1,1],[1,-1],[1,0];
        [0,1],[1,0],[1,1]};
    
boundary_val = -1000;

c_p = C - P;

for dir = 1:length(cell_cp)
    if cell_cp{dir} == c_p
        break;
    end
end

max_val = boundary_val;

for i = 1:size(cell_n,2)
    tempN = C + cell_n{dir,i};
    if(max_val < grad_img(tempN(1),tempN(2)))
        max_val = grad_img(tempN(1),tempN(2));
        N = tempN;
    end
end